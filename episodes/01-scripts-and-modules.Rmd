---
title: "Python Scripts and Modules"
teaching: 10
exercises: 2
---

:::::::::::::::::::::::::::::::::::::: questions 

- What is a 'module' in Python? How does this differ from a 'script'?
- What are the benefits of modularising our Python code?

::::::::::::::::::::::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::: objectives

- Introduce the example library used in this lesson.
- Understand the limitations of scripts.
- Learn how to convert a simple script into a reusable module.

::::::::::::::::::::::::::::::::::::::::::::::::

## Introduction

Due to its expressiveness, simplicity, and rich ecosystem of external libraries, Python
is well suited for data processing and analysis, and it is commonly used as a scripting
language by scientists and engineers. In this context, a 'script' can be understood as
file containing Python commands that we might run on the command line. This may be a
linear series of simple expressions, but it can also include functions and classes.

For example, the following Python script might be used for epidemiology modelling. It
solves a SIR model, which models the number of Susceptible, Infected, and Recovered
individuals as a pathogen spreads through a population. It isn't necessary to
understand how this works in detail, but the general pattern of the code -- set up
inputs, solve a problem, plot the results -- should be familiar to those working in a
data-oriented field. It uses the popular plotting library [Matplotlib](matplotlib) to
generate a figure.

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: instructor

It isn't necessary to dwell on the details of the script. It's only being used
as an example of the sort of script the students might be familiar with.

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

```python
import matplotlib.pyplot as plt

# Inputs
# Total number of susceptible people at the start of an outbreak
pop_size = 8000000
# Average no. of new infections per infected person per day
beta = 0.5
# Inverse of the average number of days taken to recover
gamma = 0.1
# Number of days to run the simulation for
days = 150
# Number of infected people at the start of the simulation
I_0 = 10

# Initialise data
S = [] # Number of susceptible people each day
I = [] # Number of infected people each day
R = [] # Number of recovered people each day
S.append(pop_size - I_0)
I.append(I_0)
R.append(0)

# Solve model
for i in range(days):
    # Get rate of change of S, I, and R
    dS = - beta * S[i] * I[i] / pop_size
    dR = gamma * I[i]
    dI = -(dS + dR)
    # Get values on next day
    S.append(S[i] + dS)
    I.append(I[i] + dI)
    R.append(R[i] + dR)

# Plot results
plt.plot(range(len(S)), S, label="S")
plt.plot(range(len(I)), I, label="I")
plt.plot(range(len(R)), R, label="R")
plt.xlabel("Time /days")
plt.ylabel("Population")
plt.legend()
plt.show()
```

If we save this script to the file `SIR_model_scripy.py`, it can then be run from the
command line as follows:

```bash
$ python3 SIR_model_script.py
```

If everything works as expected, it should produce the following result:

![SIR model results](fig/SIR_model.png){alt="A plot generated by running the SIR model script"}

So far so good, but there are some limitations to this style of coding:

* If the user wants to change the model inputs, they have to open the script file and
  modify some lines of code before running again.
* The raw data is lost each time the code is run, so it can't be used for further
  processing.
* The user must know where the script is stored on their system, navigate to that
  directory, and call it from there.
* If we wish to expand on this functionality in a new script, we must copy the code 
  across to a new file. It would take a lot of extra effort to update both scripts
  every time we wish to adjust the core routine, and this is likely to introduce bugs.

It's important to note that there's nothing strictly _wrong_ with writing scripts in
this way, and it's often a good starting point for any new projects. However, as we
develop our project further, we might find it useful to bundle up the reusable bits 
of our code into a 'module' that we can `import` from other Python programs, just as
we `import`-ed Matplotlib in our own script.

<!-- TODO explain what a module is, what it should ideally contain, how it differs from a script -->

:::::::::::::::::::::::: challenge

What would happen if we opened the Python interpreter, and called the following code?

```python
>>> import SIR_model_script
```

::: solution

Technically, every Python script is already a module, and importing will run all of the
code inside. In this case, it will simply run the script as if we were running it from
the command line. With a little work, we can make our modules much more useful!

:::

:::::::::::::::::::::::::::::::::::

## Making a Reusable Module

We can convert the script listed above into a reusable module in a few simple steps:

- Take note of what is an _input_, and what is an _output_.
- Bundle the core algorithm into a _function_ that takes our input parameters and
  outputs the results of the SIR simulation.
- Move the plotting parts of the script into another function.

For the SIR model script above, the input parameters are as follows:

|Parameter  |Type    |Description                                                    |
|-----------|--------|---------------------------------------------------------------|
|`pop_size` |`int`   |Total number of susceptible people at the start of an outbreak |
|`beta`     |`float` |Average no. of new infections per infected person per day      |
|`gamma`    |`float` |Inverse of the average number of days taken to recover         |
|`days`     |`int`   |Number of days to run the simulation for                       |
|`I_0`      |`int`   |Number of infected people at the start of the simulation       |

And the output data is:

|Parameter |Type        |Description                           |
|----------|------------|--------------------------------------|
|`S`       |`List[int]` |Number of susceptible people each day |
|`I`       |`List[int]` |Number of infected people each day    |
|`R`       |`List[int]` |Number of recovered people each day   |

We can therefore rewrite the core algorithm as the function:

```python
def SIR_model(pop_size, beta, gamma, days, I_0):
    """
    Solves a SIR model numerically using a simple integration scheme.

    Parameters
    ----------
    pop_size, int
        Total number of susceptible people at the start of an outbreak.
    beta, float
        Average number of new infections per infected person per day.
    gamma, float
        Inverse of the average number of days taken to recover.
    days, int
        Number of days to run the simulation for.     
    I_0, int
        Number of infected people at the start of the simulation.

    Returns
    -------
    S, List[int]
        Number of susceptible people on each day.
    I, List[int]
        Number of infected people on each day.
    R, List[int]
        Number of recovered people on each day.
    """
    # Initialise data
    S = [] # Number of susceptible people each day
    I = [] # Number of infected people each day
    R = [] # Number of recovered people each day
    S.append(pop_size - I_0)
    I.append(I_0)
    R.append(0)

    # Solve model
    for i in range(days):
        # Get rate of change of S, I, and R
        dS = - beta * S[i] * I[i] / pop_size
        dR = gamma * I[i]
        dI = -(dS + dR)
        # Get values on next day
        S.append(S[i] + dS)
        I.append(I[i] + dI)
        R.append(R[i] + dR)

    return S, I, R
```

Note that we've provided a nice docstring, so that users of our function can understand
how to use it. We can similarly bundle the plotting parts of the script as follows:

```python
import matplotlib.pyplot as plt

def plot_SIR_model(S, I, R):
    """
    Plot the results of a SIR simulation.

    Parameters
    ----------
    S, List[int]
        Number of susceptible people on each day.
    I, List[int]
        Number of infected people on each day.
    R, List[int]
        Number of recovered people on each day.
    filename, str
        Name of the file

    Returns
    -------
    None
    """
    plt.plot(range(len(S)), S, label="S")
    plt.plot(range(len(I)), I, label="I")
    plt.plot(range(len(R)), R, label="R")
    plt.xlabel("Time /days")
    plt.ylabel("Population")
    plt.legend()
    plt.show()
```

If we save the two code blocks above to a file called `SIR_model.py`, we can then open
up a Python interpreter and run the following:

```python
>>> from SIR_model import SIR_model, plot_SIR_model
>>> S, I, R = SIR_model(
        pop_size=8000000, beta=0.5, gamma=0.1, days=150, I_0=10
    )
>>> plot_SIR_model(S, I, R)
```

This should give us the same results as when we ran the script earlier, and we can
run the `SIR_model` function with different inputs without needing to change the
input parameters in the file itself.

When `import`-ing, we explicitly imported the names `SIR_model` and `plot_SIR_model`
instead of using `from SIR_model import *`. The latter can be dangerous, as names from
two different imported modules could overlap, and one would overwrite the other. It's
generally better to be explicit about what we're importing. We could also import only
the module name, and access the functions within using the `SIR_model` _namespace_:

```python
>>> import SIR_model
>>> S, I, R = SIR_model.SIR_model(
        pop_size=8000000, beta=0.5, gamma=0.1, days=150, I_0=10
    )
>>> SIR_model.plot_SIR_model(S, I, R)
```

We could also assign an alias to the module name using `as`:

```python
>>> import SIR_model as sm
>>> S, I, R = sm.SIR_model(
        pop_size=8000000, beta=0.5, gamma=0.1, days=150, I_0=10
    )
>>> sm.plot_SIR_model(S, I, R)
```

The choice of whether to import individual functions into the current namespace or to
import the module and use dot-notation to access the contents is up to you. There are
widely adopted conventions for some popular libaries (i.e. [NumPy](numpy) is usually
imported using `import numpy as np`), but otherwise it comes down to personal
preference.

## Maintaining Script-Like Functionality

If we wish, we can also maintain the script-like behaviour using the
`if __name__ == "__main__".py` idiom at the bottom of the file `SIR_model.py`:

```python
if __name__ == "__main__":
    S, I, R = SIR_model(
        pop_size=8000000, beta=0.5, gamma=0.1, days=150, I_0=10
    )
    plot_SIR_model(S, I, R)
```

With this is place, we can still run the module as if it were a script:

```bash
$ python3 SIR_model.py
```

However, this section will not run if we `import` the file. Let's break down how this
works:

- Each Python module is automatically assigned a variable `__name__`, and this is
  usually set to the name of the file without the `.py` extension.

```python
>>> import SIR_model
>>> print(SIR_model.__name__)
```
```output
"SIR_model"
```

- The exception to the rule is when we run a Python module as a script. In this case,
  the top-level file instead has its `__name__` variable set to `"__main__"`.

Therefore, the code written under `if __name__ == "__main__"` will run if we use the
module as a script, but not if we `import` the file.

:::::::::::::::::: challenge
We'll create a very simple Python script, which we'll call `name_test.py`. It contains
only the following line:

```python
print(__name__)
```

What happens if we run the following on the command line?

```bash
$ python3 name_test.py
```

::: solution
It prints `"__main__"`
:::

What if instead we open an interpreter and import it?

```python
>>> import name_test
```

::: solution
It prints `"name_test"`
:::

::::::::::::::::::::::::::::

## Managing PYTHONPATH

Our script is now `import`-able, so the `SIR_model` function can be used from any other
Python script, module, or interpretter session. However, we still need to know where
the module is stored on our file system, which can make it difficult to reuse the
functions in a separate project. A simple solution is to set the `PYTHONPATH`
environment variable on our system. On Linux machines, this can be achieved using:

```bash
$ export PYTHONPATH="${PYTHONPATH}:/path/to/my/module/directory"
```

If you want this to be set every time you open a terminal, you can add the line to the
file `~/.bashrc`.

<!-- TODO: include Windows explanation -->

In a later chapter, we will show how to install our own modules using the `pip` package
manager, which gives us much more control over how we integrate our modules into our
Python environments (which may be managed using tools using `venv` or `conda`), and
also allows us to install packages from a remote repository. We'll also show how to
upload our own packages to the remote repository PyPI, and therefore allow others to
download and install our code from the command line!


:::::::::::::::::::::::::::::: keypoints

- Any Python file can be considered a 'module', and can be `import`-ed. This just runs
  the code in the file, and makes the names of any objects in the module accessible
  using dot-notation.
- If we bundle our Python scripts into a collection of functions, we can reuse those
  functions in other modules or in the Python interpretter.
- After turning our scripts into reusable modules, we can maintain script-like behaviour
  using the idiom `if __name__ == "__main__"`.

::::::::::::::::::::::::::::::::::::::::
